#include "bihc.h"
#include <string.h>
#include <stdlib.h>
#include <io.h>

static FILE *ofp;
int currentLevel=1;
static int highlightLevel;
int inCode=0;
static int insideTopic=0;
static char topickeyname[128];

#pragma off(unreferenced);

static const char *specialCharName(char c) {
        static const struct {
                char c;
                const char *s;
        } special[] = {
                {' ',   "&aa."},
//                {'ƒ',   "&ac."),
                {'„',   "&ae."},
                {'Ž',   "&Ae."},
                {'…',   "&ag."},
                {'‘',   "&aelig."},
                {'’',   "&AElig."},
                //alpha
                {'&',   "&amp."},
                //and
                //anstrom
                {'†',   "&ao."},
                {'',   "&Ao."},
                {'\'',  "&apos."},
                //box drawing not included
                //asterisk
                //atsign
                //backslash
                {'á',   "&Beta."},
                //box stuff
                {'‡',   "&cc."},
                {'€',   "&Cc."},
                //caret
                //close double quote
                //close french quote
                //close single quote
                //comma
                {':',   "&colon."},
                //dash
                {'ø',   "&degree."},
                {'ö',   "&divide."},
                //dollar
                //dot
                //down arrow
                {'‚',   "&ea."},
                {'',   "&Ea."},
                {'ˆ',   "&ec."},
                {'‰',   "&ee."},
                {'Š',   "&eg."},
                //em dash
                //en dash
                //equal sign
                //exclamation point
                {'Ÿ',   "&fnof."},
                //greater than
                {'',   "&house."},
                //hyphen
                {'¡',   "&ia."},
                {'Œ',   "&ic."},
                {'‹',   "&ie."},
                {'',   "&ig."},
                {'­',   "&inve."},
                {'¨',   "&invq."},
                //left arrow
                //left arrowhead
                //lbrace
                //lbracket
                //lparen
                {'ª',   "&lnot."},
                //em dash
                //minus sign
                {'æ',   "&mu."},
                //en dash
                {'¤',   "&nt."},
                {'¥',   "&Nt."},
                //not symbol
                //number sign
                {'¢',   "&oa."},
                {'“',   "&oc."},
                {'•',   "&og."},
                {'”',   "&oe."},
                {'™',   "&Oe."},
                //one fourth
                //one half
                //open double quote
                //open french quote
                //open single quote
                //percent
                //period
                //plus sign
                {'ñ',   "&plusmin."},
                //pound sterling
                {'ÿ',   "&rbl."},
                //right arrow
                //right arrowhead
                //right brace
                //right bracket
                //right paren
                //semicolon
                //shaded boxes
                //slash
                //solid box
                //solid box bottom half
                //piping symbol
                //square bullet
                {'ý',   "&sup2."},
                //tilde
                {'£',   "&ua."},
                {'–',   "&uc."},
                {'',   "&ue."},
                {'š',   "&Ue."},
                //underscore
                {'¦',   "&aus."},
                {'§',   "&ous."},
                {'˜',   "&ye."},
                {'\0',  0}
        };
        for(unsigned i=0; special[i].c; i++)
                if(special[i].c==c)
                        return special[i].s;
        return 0;
}

static void outputSymbolChar(char c) {
        static char lastchar=0;
        if(lastchar=='.' && c=='.') {
                //IPFC doesn't like ellipsis
                fprintf(ofp, "&per.");
        } else {
                const char *s=specialCharName(c);
                if(s)
                        fprintf(ofp, "%s",s);
                else
                        fprintf(ofp, "%c",c);
        }
        lastchar=c;
}

static void outputSymbolString(const char *s) {
        while(*s) outputSymbolChar(*s++);
}


//
// The IPF format
//
void OutputFileStart(const char *filename)
{
        ofp=fopen(filename,"w");
        if(!ofp)
                error("Could not create '%s'",filename);
        fprintf(ofp, ".* generated by BIHC (compiled %s %s)\n",__DATE__,__TIME__);
        if(!multiHelp) {
                fprintf(ofp, ":userdoc.\n");
                fprintf(ofp, ":title. insert your title here\n");
                fprintf(ofp, ":docprof toc=123.\n");
                fprintf(ofp, "\n");
        }
}

void OutputFileEnd()
{
        if(!multiHelp)
                fprintf(ofp, ":euserdoc.\n");
        fclose(ofp);
}


void CancelOutput(const char *outputFilename) {
        fclose(ofp);
        remove(outputFilename);
}



void dir_todo(int argc, char **argv) {
        //argv[0] : todo-string
        fprintf(ofp, ":todo what=%s.\n",argv[0]);
}

//--caution---
void dir_caution(int argc, char **argv) {
        fprintf(ofp, ":caution.");
        skipWhiteAndNL();
}
void dir_ecaution(int argc, char **argv) {
        fprintf(ofp, ":ecaution.");
}

//---definition list---
void dir_dl(int argc, char **argv) {
        //(argv[0] : term-heading
        //argv[1] : description-heading
        //)
        //argv[2] : term-size
        if(argc==0) {
                fprintf(ofp, ":dl break=fit.\n");
        } else if(argc==2) {
                fprintf(ofp, ":dl.\n");
                fprintf(ofp, ":dthd.%s.\n",argv[0]);
                fprintf(ofp, ":ddhd.%s.\n",argv[1]);
        } else if(argc==3) {
                fprintf(ofp, ":dl tsize=%s.\n",argv[2]);
                if(argv[0][0]) {
                        fprintf(ofp, ":dthd.%s.\n",argv[0]);
                        fprintf(ofp, ":ddhd.%s.\n",argv[1]);
                }
        } else
                error("Definition-list takes 0, 2 or 3 arguments, not %d",argc);
        skipWhiteAndNL();
}
void dir_edl(int argc, char **argv) {
        fprintf(ofp, ":edl.");
}
void dir_dt(int argc, char **argv) {
        fprintf(ofp, ":dt.");
        skipWhiteAndNL();
}
void dir_dd(int argc, char **argv) {
        fprintf(ofp, ":dd.");
        skipWhiteAndNL();
}

//---footnote---
void dir_footnote(int argc, char **argv) {
        //argv[0] : footnote-ID
        fprintf(ofp, ":fn id=%s.\n",argv[0]);
        insideTopic=1;
}
void dir_efootnote(int argc, char **argv) {
        fprintf(ofp, ":efn.");
        insideTopic=0;
}

//---topic---
static char *makeIndexID(char *d, const char *s) {
        char *dd=d;
        while(*s) {
                if((*s>='0' && *s<='9') ||
                   (*s>='A' && *s<='Z') ||
                   (*s>='a' && *s<='z') ||
                   *s=='_'
                  )
                        *d++=*s;
                else
                        *d++='_';
                s++;
        }
        *d='\0';
        return dd;
}

static const char *topicfullname;
void dir_topic(int argc, char **argv) {
        //argv[0] : topic-ID
        //argv[1] : level
        //argv[2] : title
        //(argv[3]: full name)
        //(argv[4]: 'primary' or 'secondary')
        enum { upafter, down, same, downonce} level;
        if(stricmp(argv[1],"upafter")==0) level=upafter;
        else if(stricmp(argv[1],"down")==0) level=down;
        else if(stricmp(argv[1],"same")==0) level=same;
        else if(stricmp(argv[1],"downonce")==0) level=downonce;
        else error("<level> must be 'upafter', 'down', 'same' or 'downonce'");
        if(level==down || level==downonce) currentLevel++;

        //output heading tag
        fprintf(ofp, ":h%d id=%s.",currentLevel,argv[0]);
        outputSymbolString(argv[2]);
        fprintf(ofp, "\n");

        topicfullname = argc>=4?argv[3]:argv[2];

        if(autoIndex || argc>=5) {
                //output automatic index tags (will most certainly produce a lot of warnings)
                char indexid[128];
                makeIndexID(indexid,argv[2]);
                if(autoIndex && (argc<5 || stricmp(argv[4],"primary")==0 || stricmp(argv[4],"only")==0)) {
                        fprintf(ofp, ":i1 id=%s.", indexid);
                        outputSymbolString(argv[2]);
                        fprintf(ofp, "\n");
                }
                if(autoIndex && (argc<5 || stricmp(argv[4],"secondary")==0 || stricmp(argv[4],"primary")==0)) {
                        fprintf(ofp, ":i2 refid=%s.", indexid);
                        outputSymbolString(topicfullname);
                        fprintf(ofp, "\n");
                }
        }

        skipWhiteAndNL();
        fprintf(ofp, ":p.\n");
        if(level==upafter || level==downonce) currentLevel--;
        insideTopic=1;

        strcpy(topickeyname, argc>=4?argv[3]:argv[2]); //remember topic name for keywords
}
void dir_etopic(int argc, char **argv) {
        //nothing
        fprintf(ofp, "\n\n");
        insideTopic=0;
}
void dir_key(int argc, char **argv) {
        //argv[0] : search-key
        //(argv[1] : 'primary' or 'secondary')
        char indexid[128];
        makeIndexID(indexid,argv[0]);

        if(argc>1 && stricmp(argv[1],"primary")==0) {
                fprintf(ofp, ":i1 id=%s.", indexid);
                outputSymbolString(argv[0]);
                fprintf(ofp, "\n");
        }
        fprintf(ofp, ":i2 refid=%s.", indexid);
        outputSymbolString(topicfullname);
        fprintf(ofp, "\n");

        skipWhiteAndNL();
}

//--reference---
void dir_ref(int argc, char **argv) {
        //argv[0] : ID
        //argv[1] : link-text
        fprintf(ofp, ":link reftype=hd refid=%s.",argv[0]);
        outputSymbolString(argv[1]);
        fprintf(ofp, ":elink.");
}

void dir_reffootnote(int argc, char **argv) {
        //argv[0] : ID
        //argv[1] : link-text
        fprintf(ofp, ":link reftype=fn refid=%s.",argv[0]);
        outputSymbolString(argv[1]);
        fprintf(ofp, ":elink.");
}

//--highlight---
void dir_hp(int argc, char **argv) {
        //argv[0] : highlight level
        highlightLevel=atoi(argv[0]);
        if(highlightLevel<0 || highlightLevel>9)
                error("highlight-level must be between 1 and 9");
        fprintf(ofp, ":hp%d.",highlightLevel);
}
void dir_ehp(int argc, char **argv) {
        fprintf(ofp, ":ehp%d.",highlightLevel);
}

//---note---
void dir_note(int argc, char **argv) {
        fprintf(ofp, ":nt.");
        skipWhiteAndNL();
}
void dir_enote(int argc, char **argv) {
        fprintf(ofp, ":ent.\n");
        skipWhiteAndNL();
}

//--ordered list---
void dir_ol(int argc, char **argv) {
        fprintf(ofp, ":ol.");
        skipWhiteAndNL();
}
void dir_eol(int argc, char **argv) {
        fprintf(ofp, ":eol.");
}

void dir_li(int argc, char **argv) {
        fprintf(ofp, ":li.");
        skipWhiteAndNL();
}

//--parameter list---
void dir_parml(int argc, char **argv) {
        //(argv[0] : term-size)
        fprintf(ofp, ":hp2.Parameters&colon.:ehp2.");
        if(argc==0)
                fprintf(ofp, ":parml compact break=fit.");
        else
                fprintf(ofp, ":parml compact break=fit tsize=%s.",argv[0]);
}
void dir_eparml(int argc, char **argv) {
        fprintf(ofp, ":eparml.");
}
void dir_pt(int argc, char **argv) {
        fprintf(ofp, ":pt.");
        skipWhiteAndNL();
}
void dir_pd(int argc, char **argv) {
        fprintf(ofp, ":pd.");
        skipWhiteAndNL();
}

//---simple list---
void dir_sl(int argc, char **argv) {
        fprintf(ofp, ":sl compact.");
        skipWhiteAndNL();
}
void dir_esl(int argc, char **argv) {
        fprintf(ofp, ":esl.");
}

//--unordered list---
void dir_ul(int argc, char **argv) {
        fprintf(ofp, ":ul.");
        skipWhiteAndNL();
}
void dir_eul(int argc, char **argv) {
        fprintf(ofp, ":eul.");
}

//---code---
void dir_code(int argc, char **argv) {
        fprintf(ofp, ":xmp.");
        inCode=1;
}
void dir_ecode(int argc, char **argv) {
        fprintf(ofp, ":exmp.");
        inCode=0;
}


//---graphic---
void dir_graphic(int argc, char **argv) {
        //argv[0]:  type 'bitmap', 'multiresolutionbitmap', 'hypergraphic'
        //argv[1]:  title
        //argv[2]:  type+filename
        //...
        if(stricmp(argv[0],"bitmap")==0 &&
           stricmp(argv[0],"multiresolutionbitmap")==0 &&
           stricmp(argv[0],"hypergraphic")==0)
                error("Invalid graphic type: '%s'",argv[0]);

        const char *winbmp=0;
        const char *os2bmp=0;
        const char *ascii=0;
        for(int a=2; a<argc; a++) {
                if(strnicmp(argv[a],"winbmp:",7)==0)
                        winbmp=argv[a]+7;
                else if(strnicmp(argv[a],"os2bmp:",7)==0)
                        os2bmp=argv[a]+7;
                else if(strnicmp(argv[a],"ascii:",6)==0)
                        ascii=argv[a]+6;
        }

        char path[_MAX_PATH], drive[_MAX_DRIVE], dir[_MAX_DIR], name[_MAX_FNAME], ext[_MAX_EXT];
        if(stricmp(argv[0],"bitmap")==0) {
                if(os2bmp) {
                        _splitpath(os2bmp,drive,dir,name,ext);
                        _makepath(path,drive,dir,name,".bmp");
                        fprintf(ofp, ":artwork name='%s' align=left.",path);
                } else if(winbmp) {
                        _splitpath(winbmp,drive,dir,name,ext);
                        _makepath(path,drive,dir,name,".bmp");
                        fprintf(ofp, ":artwork name='%s' align=left.",path);
                } else if(ascii) {
                        fprintf(ofp, ":cgraphic.\n");
                        FILE *afp=fopen(ascii,"r");
                        if(afp) {
                                fclose(afp);
                                char l[256];
                                while(fgets(l,256,afp))
                                        outputSymbolString(l);
                        } else {
                                warning("Could not open ascii drawing: '%s'\n",ascii);
                                fprintf(ofp, "Ascii drawing not available\n");
                        }
                        fprintf(ofp, ":ecgraphic.\n");
                } else {
                        warning("No suitable graphic is available for IPF\n");
                        fprintf(ofp, ":p. Picture not available in IPF version.\n");
                }
        } else if(stricmp(argv[0],"multiresolutionbitmap")==0) {
                //Windows' .mrb can not be used in IPF
                //But all OS/2 .bmp are multi-resolution
                if(os2bmp) {
                        _splitpath(os2bmp,drive,dir,name,ext);
                        _makepath(path,drive,dir,name,".bmp");
                        fprintf(ofp, ":artwork name='%s' align=left.",path);
                } else {
                        warning("No suitable graphic is available for IPF\n");
                        fprintf(ofp, ":p. Picture not available in IPF version.\n");
                }
        } else if(stricmp(argv[0],"hypergraphic")==0) {
                if(os2bmp) {
                        _splitpath(os2bmp,drive,dir,name,ext);
                        _makepath(path,drive,dir,name,".bmp");
                        fprintf(ofp, ":artwork name='%s' align=left ",path);
                        _makepath(path,drive,dir,name,".dat");
                        fprintf(ofp, "linkfile='%s'.\n",path);
                } else if(winbmp) {
                        //try to find a .dat file containing the artlinks
                        _splitpath(winbmp,drive,dir,name,ext);
                        _makepath(path,drive,dir,name,".dat");
                        if(access(path,0)==0) {
                                _splitpath(winbmp,drive,dir,name,ext);
                                _makepath(path,drive,dir,name,".bmp");
                                fprintf(ofp, ":artwork name='%s' align=left ",path);
                                _makepath(path,drive,dir,name,".dat");
                                fprintf(ofp, "linkfile='%s'.\n",path);
                        } else {
                                warning("artlink file '%s' is not available\n",path);
                                _splitpath(winbmp,drive,dir,name,ext);
                                _makepath(path,drive,dir,name,".bmp");
                                fprintf(ofp, ":artwork name='%s' align=left.",path);
                        }
                } else {
                        warning("No suitable hypergraphic is available for IPF\n");
                        fprintf(ofp, ":p. Hypergraphic not available in IPF version.\n");
                }
        }
        if(argv[1][0]) {
                fprintf(ofp, ":hp2.");
                outputSymbolString(argv[1]);
                fprintf(ofp, ":ehp2.\n.br\n");
        }
}



void OutputNewParagraph()
{
        if(insideTopic) {
                if(inCode)
                        fprintf(ofp, "\n\n");
                else
                        fprintf(ofp, "\n:p.\n");
        } else {
                fprintf(ofp, "\n\n");
        }
}

void OutputChar(char c)
{
        if(insideTopic)
                 outputSymbolChar(c);
}


